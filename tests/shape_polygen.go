// Code generated by polygen; DO NOT EDIT.
package tests

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
)

var (
	_ IsShape = Circle{}
	_ IsShape = Empty{}
	_ IsShape = (*Group)(nil)
	_ IsShape = (*Polygon)(nil)
	_ IsShape = Rectangle{}
)

// _ShapeTypeRegistry maps concrete types to their type names
var _ShapeTypeRegistry = map[reflect.Type]string{
	reflect.TypeOf((*Circle)(nil)).Elem():    "circle",
	reflect.TypeOf((*Empty)(nil)).Elem():     "empty",
	reflect.TypeOf((*Group)(nil)).Elem():     "group",
	reflect.TypeOf((*Polygon)(nil)).Elem():   "polygon",
	reflect.TypeOf((*Rectangle)(nil)).Elem(): "rectangle",
}

type Shape struct {
	IsShape
}

func (v Shape) MarshalJSON() ([]byte, error) {
	if v.IsShape == nil {
		return []byte("null"), nil
	}

	// Marshal the implementation first to get its fields
	implData, err := json.Marshal(v.IsShape)
	if err != nil {
		return nil, fmt.Errorf("marshaling IsShape implementation: %v", err)
	}

	typeName, err := _ShapeGetType(v.IsShape)
	if err != nil {
		return nil, fmt.Errorf("getting type for Shape: %v", err)
	}

	// If it's an empty object, just return descriptor
	if string(implData) == "{}" {
		return []byte(fmt.Sprintf("{\"%s\":\"%s\"}", "type", typeName)), nil
	}

	// Otherwise, combine descriptor with implementation fields
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("{\"%s\":\"%s\",", "type", typeName))
	buf.Write(implData[1:])

	return buf.Bytes(), nil
}

func (v *Shape) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		*v = Shape{}
		return nil
	}

	var currTypeName string
	if v.IsShape != nil {
		var err error
		currTypeName, err = _ShapeGetType(v.IsShape)
		if err != nil {
			return fmt.Errorf("getting type for existing Shape: %v", err)
		}
	}

	// First decode just the type field
	typeData := struct {
		Type string `json:"type"`
	}{
		Type: currTypeName,
	}
	if err := json.Unmarshal(data, &typeData); err != nil {
		return fmt.Errorf("unmarshaling Shape type field: %v", err)
	}

	if typeData.Type == "" {
		return fmt.Errorf("missing type field in JSON for Shape")
	}

	typeName := typeData.Type

	var value IsShape
	switch typeName {
	case "circle":
		var vv Circle
		if currTypeName == "circle" {
			vv = v.IsShape.(Circle)
		}
		if err := json.Unmarshal(data, &vv); err != nil {
			return fmt.Errorf("unmarshaling Shape as Circle: %v", err)
		}
		value = vv
	case "empty":
		var vv Empty
		if currTypeName == "empty" {
			vv = v.IsShape.(Empty)
		}
		if err := json.Unmarshal(data, &vv); err != nil {
			return fmt.Errorf("unmarshaling Shape as Empty: %v", err)
		}
		value = vv
	case "group":
		var vv *Group
		if currTypeName == "group" {
			vv = v.IsShape.(*Group)
		}
		if err := json.Unmarshal(data, &vv); err != nil {
			return fmt.Errorf("unmarshaling Shape as Group: %v", err)
		}
		value = vv
	case "polygon":
		var vv *Polygon
		if currTypeName == "polygon" {
			vv = v.IsShape.(*Polygon)
		}
		if err := json.Unmarshal(data, &vv); err != nil {
			return fmt.Errorf("unmarshaling Shape as Polygon: %v", err)
		}
		value = vv
	case "rectangle":
		var vv Rectangle
		if currTypeName == "rectangle" {
			vv = v.IsShape.(Rectangle)
		}
		if err := json.Unmarshal(data, &vv); err != nil {
			return fmt.Errorf("unmarshaling Shape as Rectangle: %v", err)
		}
		value = vv
	default:
		return fmt.Errorf("unknown Shape type: %s", typeName)
	}

	*v = Shape{
		IsShape: value,
	}
	return nil
}

func _ShapeGetType(v IsShape) (string, error) {
	t := reflect.TypeOf(v)
	// Allows using a pointer as a value
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	typeName, ok := _ShapeTypeRegistry[t]
	if !ok {
		return "", fmt.Errorf("unknown type for Shape: %v", t)
	}
	return typeName, nil
}
