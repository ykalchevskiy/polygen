// Code generated by polygen; DO NOT EDIT.
package tests

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
)

var (
	_ IsShape = Circle{}
	_ IsShape = Empty{}
	_ IsShape = (*Group)(nil)
	_ IsShape = (*Polygon)(nil)
	_ IsShape = Rectangle{}
)

// _ShapeStrictTypeRegistry maps concrete types to their type names
var _ShapeStrictTypeRegistry = map[reflect.Type]string{
	reflect.TypeOf((*Circle)(nil)).Elem():    "circle",
	reflect.TypeOf((*Empty)(nil)).Elem():     "empty",
	reflect.TypeOf((*Group)(nil)):            "group",
	reflect.TypeOf((*Polygon)(nil)):          "polygon",
	reflect.TypeOf((*Rectangle)(nil)).Elem(): "rectangle",
}

type ShapeStrict struct {
	IsShape
}

func (v ShapeStrict) MarshalJSON() ([]byte, error) {
	if v.IsShape == nil {
		return []byte("null"), nil
	}

	// Marshal the implementation first to get its fields
	implData, err := json.Marshal(v.IsShape)
	if err != nil {
		return nil, fmt.Errorf("polygen: cannot marshal IsShape for ShapeStrict: %v", err)
	}

	if bytes.Equal(implData, []byte("null")) {
		return implData, nil
	}

	typeName, _, err := _ShapeStrictGetType(v.IsShape)
	if err != nil {
		return nil, fmt.Errorf("polygen: cannot get subtype to marshal for ShapeStrict: %v", err)
	}

	// If it's an empty object, just return discriminator
	if bytes.Equal(implData, []byte("{}")) {
		return []byte(fmt.Sprintf(`{"%s":"%s"}`, "type", typeName)), nil
	}

	// Otherwise, combine discriminator with implementation fields
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf(`{"%s":"%s",`, "type", typeName))
	buf.Write(implData[1:])

	return buf.Bytes(), nil
}

func (v *ShapeStrict) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		*v = ShapeStrict{}
		return nil
	}

	var currTypeName string
	var currTypeAsPointer bool

	if v.IsShape != nil {
		var err error
		currTypeName, currTypeAsPointer, err = _ShapeStrictGetType(v.IsShape)
		if err != nil {
			return fmt.Errorf("polygen: cannot get subtype to unmarshal for ShapeStrict: %v", err)
		}
	}
	_ = currTypeAsPointer // In case of all subtypes being pointers, we must just ignore this

	// First decode just the type field
	typeData := struct {
		Type string `json:"type"`
	}{
		Type: currTypeName,
	}
	if err := json.Unmarshal(data, &typeData); err != nil {
		return fmt.Errorf("polygen: cannot unmarshal discriminator type for ShapeStrict: %v", err)
	}

	if typeData.Type == "" {
		return fmt.Errorf("polygen: missing discriminator type for ShapeStrict")
	}

	typeName := typeData.Type

	var value IsShape

	switch typeName {
	case "circle":
		if currTypeName == "circle" {
			if currTypeAsPointer {
				vv := struct {
					*Circle
					Type string `json:"type"`
				}{}
				vv.Circle = v.IsShape.(*Circle)
				decoder := json.NewDecoder(bytes.NewReader(data))
				decoder.DisallowUnknownFields()
				if err := decoder.Decode(&vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal Circle for ShapeStrict: %v", err)
				}
				value = vv.Circle
			} else {
				vv := struct {
					Circle
					Type string `json:"type"`
				}{}
				vv.Circle = v.IsShape.(Circle)
				decoder := json.NewDecoder(bytes.NewReader(data))
				decoder.DisallowUnknownFields()
				if err := decoder.Decode(&vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal Circle for ShapeStrict: %v", err)
				}
				value = vv.Circle
			}
		} else {
			vv := struct {
				Circle
				Type string `json:"type"`
			}{}
			decoder := json.NewDecoder(bytes.NewReader(data))
			decoder.DisallowUnknownFields()
			if err := decoder.Decode(&vv); err != nil {
				return fmt.Errorf("polygen: cannot unmarshal Circle for ShapeStrict: %v", err)
			}
			value = vv.Circle
		}
	case "empty":
		if currTypeName == "empty" {
			if currTypeAsPointer {
				vv := struct {
					*Empty
					Type string `json:"type"`
				}{}
				vv.Empty = v.IsShape.(*Empty)
				decoder := json.NewDecoder(bytes.NewReader(data))
				decoder.DisallowUnknownFields()
				if err := decoder.Decode(&vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal Empty for ShapeStrict: %v", err)
				}
				value = vv.Empty
			} else {
				vv := struct {
					Empty
					Type string `json:"type"`
				}{}
				vv.Empty = v.IsShape.(Empty)
				decoder := json.NewDecoder(bytes.NewReader(data))
				decoder.DisallowUnknownFields()
				if err := decoder.Decode(&vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal Empty for ShapeStrict: %v", err)
				}
				value = vv.Empty
			}
		} else {
			vv := struct {
				Empty
				Type string `json:"type"`
			}{}
			decoder := json.NewDecoder(bytes.NewReader(data))
			decoder.DisallowUnknownFields()
			if err := decoder.Decode(&vv); err != nil {
				return fmt.Errorf("polygen: cannot unmarshal Empty for ShapeStrict: %v", err)
			}
			value = vv.Empty
		}
	case "group":
		vv := struct {
			*Group
			Type string `json:"type"`
		}{}
		if currTypeName == "group" {
			vv.Group = v.IsShape.(*Group)
		} else {
			vv.Group = new(Group)
		}
		decoder := json.NewDecoder(bytes.NewReader(data))
		decoder.DisallowUnknownFields()
		if err := decoder.Decode(&vv); err != nil {
			return fmt.Errorf("polygen: cannot unmarshal Group for ShapeStrict: %v", err)
		}
		value = vv.Group
	case "polygon":
		vv := struct {
			*Polygon
			Type string `json:"type"`
		}{}
		if currTypeName == "polygon" {
			vv.Polygon = v.IsShape.(*Polygon)
		} else {
			vv.Polygon = new(Polygon)
		}
		decoder := json.NewDecoder(bytes.NewReader(data))
		decoder.DisallowUnknownFields()
		if err := decoder.Decode(&vv); err != nil {
			return fmt.Errorf("polygen: cannot unmarshal Polygon for ShapeStrict: %v", err)
		}
		value = vv.Polygon
	case "rectangle":
		if currTypeName == "rectangle" {
			if currTypeAsPointer {
				vv := struct {
					*Rectangle
					Type string `json:"type"`
				}{}
				vv.Rectangle = v.IsShape.(*Rectangle)
				decoder := json.NewDecoder(bytes.NewReader(data))
				decoder.DisallowUnknownFields()
				if err := decoder.Decode(&vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal Rectangle for ShapeStrict: %v", err)
				}
				value = vv.Rectangle
			} else {
				vv := struct {
					Rectangle
					Type string `json:"type"`
				}{}
				vv.Rectangle = v.IsShape.(Rectangle)
				decoder := json.NewDecoder(bytes.NewReader(data))
				decoder.DisallowUnknownFields()
				if err := decoder.Decode(&vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal Rectangle for ShapeStrict: %v", err)
				}
				value = vv.Rectangle
			}
		} else {
			vv := struct {
				Rectangle
				Type string `json:"type"`
			}{}
			decoder := json.NewDecoder(bytes.NewReader(data))
			decoder.DisallowUnknownFields()
			if err := decoder.Decode(&vv); err != nil {
				return fmt.Errorf("polygen: cannot unmarshal Rectangle for ShapeStrict: %v", err)
			}
			value = vv.Rectangle
		}
	default:
		return fmt.Errorf("polygen: unknown subtype for ShapeStrict: %s", typeName)
	}

	*v = ShapeStrict{
		IsShape: value,
	}
	return nil
}

func _ShapeStrictGetType(v IsShape) (name string, asPointer bool, _ error) {
	t := reflect.TypeOf(v)
	typeName, ok := _ShapeStrictTypeRegistry[t]
	if ok {
		return typeName, false, nil
	}
	// A pointer can be manually used for a value type as it also implements the interface
	if t.Kind() == reflect.Ptr {
		typeName, ok = _ShapeStrictTypeRegistry[t.Elem()]
		if ok {
			return typeName, true, nil
		}
	}
	return "", false, fmt.Errorf("unknown subtype: %v", t)
}
