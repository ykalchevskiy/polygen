// Code generated by polygen; DO NOT EDIT.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
)

// _ItemValueTypeRegistry maps concrete types to their type names
var _ItemValueTypeRegistry = map[reflect.Type]string{
	reflect.TypeOf((*TextItem)(nil)).Elem():  "text",
	reflect.TypeOf((*ImageItem)(nil)).Elem(): "image",
}

type ItemValue struct {
	IsItemValue
}

func (v ItemValue) MarshalJSON() ([]byte, error) {
	if v.IsItemValue == nil {
		return []byte("null"), nil
	}

	// Marshal the implementation first to get its fields
	implData, err := json.Marshal(v.IsItemValue)
	if err != nil {
		return nil, fmt.Errorf("marshaling IsItemValue implementation: %v", err)
	}

	// Get type name from registry using the concrete type
	t := reflect.TypeOf(v.IsItemValue)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	typeName, ok := _ItemValueTypeRegistry[t]
	if !ok {
		return nil, fmt.Errorf("unknown type for ItemValue: %v", t)
	}

	// If it's an empty object, just return descriptor
	if string(implData) == "{}" {
		return []byte(fmt.Sprintf("{\"%s\":\"%s\"}", "kind", typeName)), nil
	}

	// Otherwise, combine descriptor with implementation fields
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("{\"%s\":\"%s\",", "kind", typeName))
	buf.Write(implData[1:])

	return buf.Bytes(), nil
}

func (v *ItemValue) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		*v = ItemValue{}
		return nil
	}
	return v.unmarshalNonStrict(data)
}
func (v *ItemValue) unmarshalNonStrict(data []byte) error {
	// First unmarshal to get the type
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return fmt.Errorf("unmarshaling ItemValue raw: %v", err)
	}

	// Check and extract type field
	typeData, exists := raw["kind"]
	var typeName string
	if !exists {
		// If no type field and we have an existing value, decode into it non-strictly
		if v.IsItemValue != nil {
			return json.Unmarshal(data, v.IsItemValue)
		}
		return fmt.Errorf("missing kind field in JSON for ItemValue")
	}
	if err := json.Unmarshal(typeData, &typeName); err != nil {
		return fmt.Errorf("unmarshaling ItemValue type value: %v", err)
	}

	var value IsItemValue
	switch typeName {
	case "text":
		var v TextItem
		if err := json.Unmarshal(data, &v); err != nil {
			return fmt.Errorf("unmarshaling ItemValue as TextItem: %v", err)
		}
		value = v
	case "image":
		var v ImageItem
		if err := json.Unmarshal(data, &v); err != nil {
			return fmt.Errorf("unmarshaling ItemValue as ImageItem: %v", err)
		}
		value = v
	default:
		return fmt.Errorf("unknown ItemValue type: %s", typeName)
	}

	*v = ItemValue{
		IsItemValue: value,
	}
	return nil
}
