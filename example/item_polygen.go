// Code generated by polygen; DO NOT EDIT.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
)

// _ItemTypeRegistry maps concrete types to their type names
var _ItemTypeRegistry = map[reflect.Type]string{
	reflect.TypeOf((*ImageItem)(nil)).Elem(): "image",
	reflect.TypeOf((*TextItem)(nil)).Elem():  "text",
}

type Item struct {
	IsItem
}

func (v Item) MarshalJSON() ([]byte, error) {
	if v.IsItem == nil {
		return []byte("null"), nil
	}

	// Marshal the implementation first to get its fields
	implData, err := json.Marshal(v.IsItem)
	if err != nil {
		return nil, fmt.Errorf("marshaling IsItem implementation: %v", err)
	}

	typeName, err := _ItemGetType(v.IsItem)
	if err != nil {
		return nil, fmt.Errorf("getting type for Item: %v", err)
	}

	// If it's an empty object, just return descriptor
	if string(implData) == "{}" {
		return []byte(fmt.Sprintf("{\"%s\":\"%s\"}", "kind", typeName)), nil
	}

	// Otherwise, combine descriptor with implementation fields
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("{\"%s\":\"%s\",", "kind", typeName))
	buf.Write(implData[1:])

	return buf.Bytes(), nil
}

func (v *Item) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		*v = Item{}
		return nil
	}

	// First decode just the type field
	typeData := struct {
		Type string `json:"kind"`
	}{}
	if err := json.Unmarshal(data, &typeData); err != nil {
		return fmt.Errorf("unmarshaling Item type field: %v", err)
	}

	var currTypeName string

	if typeData.Type == "" {
		if v.IsItem != nil {
			var err error
			currTypeName, err = _ItemGetType(v.IsItem)
			if err != nil {
				return fmt.Errorf("getting type for existing Item: %v", err)
			}
			typeData.Type = currTypeName
		} else {
			return fmt.Errorf("missing kind field in JSON for Item")
		}
	}

	typeName := typeData.Type

	var value IsItem
	switch typeName {
	case "image":
		vv := struct {
			*ImageItem
			Type string `json:"kind"`
		}{}
		if currTypeName == "image" {
			vv.ImageItem = v.IsItem.(*ImageItem)
		}
		decoder := json.NewDecoder(bytes.NewReader(data))
		decoder.DisallowUnknownFields()
		if err := decoder.Decode(&vv); err != nil {
			return fmt.Errorf("unmarshaling Item as ImageItem: %v", err)
		}
		value = vv.ImageItem
	case "text":
		vv := struct {
			TextItem
			Type string `json:"kind"`
		}{}
		if currTypeName == "text" {
			vv.TextItem = v.IsItem.(TextItem)
		}
		decoder := json.NewDecoder(bytes.NewReader(data))
		decoder.DisallowUnknownFields()
		if err := decoder.Decode(&vv); err != nil {
			return fmt.Errorf("unmarshaling Item as TextItem: %v", err)
		}
		value = vv.TextItem
	default:
		return fmt.Errorf("unknown Item type: %s", typeName)
	}

	*v = Item{
		IsItem: value,
	}
	return nil
}

func _ItemGetType(v IsItem) (string, error) {
	t := reflect.TypeOf(v)
	// Allows using a pointer as a value
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	typeName, ok := _ItemTypeRegistry[t]
	if !ok {
		return "", fmt.Errorf("unknown type for Item: %v", t)
	}
	return typeName, nil
}
