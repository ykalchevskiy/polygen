// Code generated by polygen; DO NOT EDIT.
package {{.Package}}

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
)

var (
{{- range .Types}}
{{- if .IsPointer}}
	_ {{$.Interface}} = (*{{.SubType}})(nil)
{{- else}}
	_ {{$.Interface}} = {{.SubType}}{}
{{- end}}
{{- end}}
)

// _{{.Type}}TypeRegistry maps concrete types to their type names
var _{{.Type}}TypeRegistry = map[reflect.Type]string{
{{- range .Types}}
	reflect.TypeOf((*{{.SubType}})(nil)).Elem(): "{{.TypeName}}",
{{- end}}
}

type {{.Type}} struct {
	{{.Interface}}
}

func (v {{.Type}}) MarshalJSON() ([]byte, error) {
	if v.{{.Interface}} == nil {
		return []byte("null"), nil
	}

	// Marshal the implementation first to get its fields
	implData, err := json.Marshal(v.{{.Interface}})
	if err != nil {
		return nil, fmt.Errorf("marshaling {{.Interface}} implementation: %v", err)
	}

	typeName, err := _{{.Type}}GetType(v.{{.Interface}})
	if err != nil {
		return nil, fmt.Errorf("getting type for {{.Type}}: %v", err)
	}

	// If it's an empty object, just return descriptor
	if string(implData) == "{}" {
		return []byte(fmt.Sprintf("{\"%s\":\"%s\"}", "{{.Descriptor}}", typeName)), nil
	}

	// Otherwise, combine descriptor with implementation fields
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("{\"%s\":\"%s\",", "{{.Descriptor}}", typeName))
	buf.Write(implData[1:])

	return buf.Bytes(), nil
}

func (v *{{.Type}}) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		*v = {{.Type}}{}
		return nil
	}

	var currTypeName string
	if v.{{.Interface}} != nil {
		var err error
		currTypeName, err = _{{.Type}}GetType(v.{{.Interface}})
		if err != nil {
			return fmt.Errorf("getting type for existing {{.Type}}: %v", err)
		}
	}

	// First decode just the type field
	typeData := struct {
		Type string `json:"{{.Descriptor}}"`
	}{
		Type: currTypeName,
	}
	if err := json.Unmarshal(data, &typeData); err != nil {
		return fmt.Errorf("unmarshaling {{.Type}} type field: %v", err)
	}

	if typeData.Type == "" {
		return fmt.Errorf("missing {{.Descriptor}} field in JSON for {{.Type}}")
	}

 	typeName := typeData.Type

	var value {{.Interface}}
	switch typeName {
	{{- range .Types}}
	case "{{.TypeName}}":
		{{- if $.Strict}}
			vv := struct {
				{{- if .IsPointer}}*{{- end}}{{.SubType}}
				Type string `json:"{{$.Descriptor}}"`
			}{}
			if currTypeName == "{{.TypeName}}" {
				{{- if .IsPointer}}
				vv.{{.SubType}} = v.{{$.Interface}}.(*{{.SubType}})
				{{- else}}
				vv.{{.SubType}} = v.{{$.Interface}}.({{.SubType}})
				{{- end}}
			} {{ if .IsPointer}} else {
				vv.{{.SubType}} = new({{.SubType}})
			}
			{{- end}}
			decoder := json.NewDecoder(bytes.NewReader(data))
			decoder.DisallowUnknownFields()
			if err := decoder.Decode(&vv); err != nil {
				return fmt.Errorf("unmarshaling {{$.Type}} as {{.SubType}}: %v", err)
			}
			value = vv.{{.SubType}}
		{{- else}}
			var vv {{if .IsPointer}}*{{- end}}{{.SubType}}
			if currTypeName == "{{.TypeName}}" {
				{{- if .IsPointer}}
				vv = v.{{$.Interface}}.(*{{.SubType}})
				{{- else}}
				vv = v.{{$.Interface}}.({{.SubType}})
				{{- end}}
			}
			if err := json.Unmarshal(data, &vv); err != nil {
				return fmt.Errorf("unmarshaling {{$.Type}} as {{.SubType}}: %v", err)
			}
			value = vv
		{{- end}}
	{{- end}}
	default:
		return fmt.Errorf("unknown {{.Type}} type: %s", typeName)
	}

	*v = {{.Type}}{
		{{.Interface}}: value,
	}
	return nil
}

func _{{.Type}}GetType(v {{.Interface}}) (string, error) {
	t := reflect.TypeOf(v)
	// Allows using a pointer as a value
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	typeName, ok := _{{.Type}}TypeRegistry[t]
	if !ok {
		return "", fmt.Errorf("unknown type for {{.Type}}: %v", t)
	}
	return typeName, nil
}
