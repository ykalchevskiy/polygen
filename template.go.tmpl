// Code generated by polygen; DO NOT EDIT.
package {{.Package}}

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
)

var (
{{- range .Types}}
{{- if .IsPointer}}
	_ {{$.Interface}} = (*{{.SubType}})(nil)
{{- else}}
	_ {{$.Interface}} = {{.SubType}}{}
{{- end}}
{{- end}}
)

// _{{.Type}}TypeRegistry maps concrete types to their type names
var _{{.Type}}TypeRegistry = map[reflect.Type]string{
{{- range .Types}}
	reflect.TypeOf((*{{.SubType}})(nil)){{- if not .IsPointer}}.Elem(){{- end}}: "{{.TypeName}}",
{{- end}}
}

type {{.Type}} struct {
	{{.Interface}}
}

func (v {{.Type}}) MarshalJSON() ([]byte, error) {
	if v.{{.Interface}} == nil {
		return []byte("null"), nil
	}

	// Marshal the implementation first to get its fields
	implData, err := json.Marshal(v.{{.Interface}})
	if err != nil {
		return nil, fmt.Errorf("polygen: cannot marshal {{.Interface}} for {{.Type}}: %v", err)
	}

	if bytes.Equal(implData, []byte("null")) {
		return implData, nil
 	}

	typeName, _, err := _{{.Type}}GetType(v.{{.Interface}})
	if err != nil {
		return nil, fmt.Errorf("polygen: cannot get subtype to marshal for {{.Type}}: %v", err)
	}

	// If it's an empty object, just return descriptor
	if bytes.Equal(implData, []byte("{}")) {
		return []byte(fmt.Sprintf(`{"%s":"%s"}`, "{{.Descriptor}}", typeName)), nil
	}

	// Otherwise, combine descriptor with implementation fields
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf(`{"%s":"%s",`, "{{.Descriptor}}", typeName))
	buf.Write(implData[1:])

	return buf.Bytes(), nil
}

func (v *{{.Type}}) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		*v = {{.Type}}{}
		return nil
	}

	var currTypeName string
	var currTypeAsPointer bool

	if v.{{.Interface}} != nil {
		var err error
		currTypeName, currTypeAsPointer, err = _{{.Type}}GetType(v.{{.Interface}})
		if err != nil {
			return fmt.Errorf("polygen: cannot get subtype to unmarshal for {{.Type}}: %v", err)
		}
	}
	_ = currTypeAsPointer // In case of all subtypes being pointers, we must just ignore this

	// First decode just the type field
	typeData := struct {
		Type string `json:"{{.Descriptor}}"`
	}{
		Type: currTypeName,
	}
	if err := json.Unmarshal(data, &typeData); err != nil {
		return fmt.Errorf("polygen: cannot unmarshal descriptor field {{.Descriptor}} for {{.Type}}: %v", err)
	}

	if typeData.Type == "" {
		return fmt.Errorf("polygen: missing descriptor field {{.Descriptor}} for {{.Type}}")
	}

 	typeName := typeData.Type

	var value {{.Interface}}

	switch typeName {
	{{- range .Types}}
	case "{{.TypeName}}":
		{{- if $.Strict}}
			{{- if .IsPointer}}
				vv := struct {
					*{{.SubType}}
					Type string `json:"{{$.Descriptor}}"`
				}{}
				if currTypeName == "{{.TypeName}}" {
					vv.{{.SubType}} = v.{{$.Interface}}.(*{{.SubType}})
				} else {
					vv.{{.SubType}} = new({{.SubType}})
				}
				decoder := json.NewDecoder(bytes.NewReader(data))
				decoder.DisallowUnknownFields()
				if err := decoder.Decode(&vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
				}
				value = vv.{{.SubType}}
			{{- else}}
				if currTypeName == "{{.TypeName}}" {
					if currTypeAsPointer {
						vv := struct {
							*{{.SubType}}
							Type string `json:"{{$.Descriptor}}"`
						}{}
						vv.{{.SubType}} = v.{{$.Interface}}.(*{{.SubType}})
						decoder := json.NewDecoder(bytes.NewReader(data))
						decoder.DisallowUnknownFields()
						if err := decoder.Decode(&vv); err != nil {
							return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
						}
						value = vv.{{.SubType}}
					} else {
						vv := struct {
							{{.SubType}}
							Type string `json:"{{$.Descriptor}}"`
						}{}
						vv.{{.SubType}} = v.{{$.Interface}}.({{.SubType}})
						decoder := json.NewDecoder(bytes.NewReader(data))
						decoder.DisallowUnknownFields()
						if err := decoder.Decode(&vv); err != nil {
							return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
						}
						value = vv.{{.SubType}}
					}
				} else {
					vv := struct {
						{{.SubType}}
						Type string `json:"{{$.Descriptor}}"`
					}{}
					decoder := json.NewDecoder(bytes.NewReader(data))
					decoder.DisallowUnknownFields()
					if err := decoder.Decode(&vv); err != nil {
						return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
					}
					value = vv.{{.SubType}}
				}
			{{- end}}
		{{- else}}
			{{- if .IsPointer}}
				var vv *{{.SubType}}
				if currTypeName == "{{.TypeName}}" {
					vv = v.{{$.Interface}}.(*{{.SubType}})
				}
				if err := json.Unmarshal(data, &vv); err != nil {
					return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
				}
				value = vv
			{{- else}}
				if currTypeName == "{{.TypeName}}" {
					if currTypeAsPointer {
						vv := v.{{$.Interface}}.(*{{.SubType}})
						if err := json.Unmarshal(data, &vv); err != nil {
							return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
						}
						value = vv
					} else {
						vv := v.{{$.Interface}}.({{.SubType}})
						if err := json.Unmarshal(data, &vv); err != nil {
							return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
						}
						value = vv
					}
				} else {
					var vv {{.SubType}}
					if err := json.Unmarshal(data, &vv); err != nil {
						return fmt.Errorf("polygen: cannot unmarshal {{.SubType}} for {{$.Type}}: %v", err)
					}
					value = vv
				}
			{{- end}}
		{{- end}}
	{{- end}}
	default:
		return fmt.Errorf("polygen: unknown subtype for {{.Type}}: %s", typeName)
	}

	*v = {{.Type}}{
		{{.Interface}}: value,
	}
	return nil
}

func _{{.Type}}GetType(v {{.Interface}}) (name string, asPointer bool, _ error) {
	t := reflect.TypeOf(v)
	typeName, ok := _{{.Type}}TypeRegistry[t]
	if ok {
		return typeName, false, nil
	}
	// A pointer can be manually used for a value type as it also implements the interface
	if t.Kind() == reflect.Ptr {
		typeName, ok = _{{.Type}}TypeRegistry[t.Elem()]
		if ok {
			return typeName, true, nil
		}
	}
	return "", false, fmt.Errorf("unknown subtype: %v", t)
}
