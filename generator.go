package main

import (
	"bytes"
	"fmt"
	"go/format"
	"text/template"
)

const codeTemplate = `// Code generated by polygen; DO NOT EDIT.
package {{.Package}}

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
)

// _{{.Type}}TypeRegistry maps concrete types to their type names
var _{{.Type}}TypeRegistry = map[reflect.Type]string{
{{- range .Types}}
	reflect.TypeOf((*{{.SubType}})(nil)).Elem(): "{{.TypeName}}",
{{- end}}
}

type {{.Type}} struct {
	{{.Interface}}
}

func (v {{.Type}}) MarshalJSON() ([]byte, error) {
	if v.{{.Interface}} == nil {
		return []byte("null"), nil
	}

	// Marshal the implementation first to get its fields
	implData, err := json.Marshal(v.{{.Interface}})
	if err != nil {
		return nil, fmt.Errorf("marshaling {{.Interface}} implementation: %v", err)
	}

	// Get type name from registry using the concrete type
	t := reflect.TypeOf(v.{{.Interface}})
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	typeName, ok := _{{.Type}}TypeRegistry[t]
	if !ok {
		return nil, fmt.Errorf("unknown type for {{.Type}}: %v", t)
	}

	// If it's an empty object, just return descriptor
	if string(implData) == "{}" {
		return []byte(fmt.Sprintf("{\"%s\":\"%s\"}", "{{.Descriptor}}", typeName)), nil
	}

	// Otherwise, combine descriptor with implementation fields
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("{\"%s\":\"%s\",", "{{.Descriptor}}", typeName))
	buf.Write(implData[1:])

	return buf.Bytes(), nil
}

func (v *{{.Type}}) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		*v = {{.Type}}{}
		return nil
	}

	{{- if .Strict}}
	return v.unmarshalStrict(data)
	{{- else}}
	return v.unmarshalNonStrict(data)
	{{- end}}
}

{{- if .Strict}}
func (v *{{.Type}}) unmarshalStrict(data []byte) error {
	// First unmarshal to get the type
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return fmt.Errorf("unmarshaling {{.Type}} raw: %v", err)
	}

	// Check and extract type field
	typeData, exists := raw["{{.Descriptor}}"]
	var typeName string
	if !exists {
		// If no type field and we have an existing value, decode into it strictly
		if v.{{.Interface}} != nil {
			decoder := json.NewDecoder(bytes.NewReader(data))
			decoder.DisallowUnknownFields()
			return decoder.Decode(v.{{.Interface}})
		}
		return fmt.Errorf("missing {{.Descriptor}} field in JSON for {{.Type}}")
	}
	if err := json.Unmarshal(typeData, &typeName); err != nil {
		return fmt.Errorf("unmarshaling {{.Type}} type value: %v", err)
	}

	var value {{.Interface}}
	switch typeName {
	{{- range .Types}}
	case "{{.TypeName}}":
		v := struct {
		   		{{.SubType}}
		   		Type string ` + "`json:\"{{$.Descriptor}}\"`" + `
		}{}
		// var v {{.SubType}}
		decoder := json.NewDecoder(bytes.NewReader(data))
		decoder.DisallowUnknownFields()
		if err := decoder.Decode(&v); err != nil {
			return fmt.Errorf("unmarshaling {{$.Type}} as {{.SubType}}: %v", err)
		}
		{{- if .IsPointer}}
		value = &v.{{.SubType}}
		{{- else}}
		value = v.{{.SubType}}
		{{- end}}
	{{- end}}
	default:
		return fmt.Errorf("unknown {{.Type}} type: %s", typeName)
	}

	*v = {{.Type}}{
		{{.Interface}}: value,
	}
	return nil
}
{{- end}}

{{- if not .Strict}}
func (v *{{.Type}}) unmarshalNonStrict(data []byte) error {
	// First unmarshal to get the type
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return fmt.Errorf("unmarshaling {{.Type}} raw: %v", err)
	}

	// Check and extract type field
	typeData, exists := raw["{{.Descriptor}}"]
	var typeName string
	if !exists {
		// If no type field and we have an existing value, decode into it non-strictly
		if v.{{.Interface}} != nil {
			return json.Unmarshal(data, v.{{.Interface}})
		}
		return fmt.Errorf("missing {{.Descriptor}} field in JSON for {{.Type}}")
	}
	if err := json.Unmarshal(typeData, &typeName); err != nil {
		return fmt.Errorf("unmarshaling {{.Type}} type value: %v", err)
	}

	var value {{.Interface}}
	switch typeName {
	{{- range .Types}}
	case "{{.TypeName}}":
		var v {{.SubType}}
		if err := json.Unmarshal(data, &v); err != nil {
			return fmt.Errorf("unmarshaling {{$.Type}} as {{.SubType}}: %v", err)
		}
		{{- if .IsPointer}}
		value = &v
		{{- else}}
		value = v
		{{- end}}
	{{- end}}
	default:
		return fmt.Errorf("unknown {{.Type}} type: %s", typeName)
	}

	*v = {{.Type}}{
		{{.Interface}}: value,
	}
	return nil
}
{{- end}}
`

func generate(cfg *Config) (string, error) {
	tmpl, err := template.New("code").Parse(codeTemplate)
	if err != nil {
		return "", fmt.Errorf("parsing template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, cfg); err != nil {
		return "", fmt.Errorf("failed to execute template: %v", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", fmt.Errorf("failed to format code: %v", err)
	}

	return string(formatted), nil
}
